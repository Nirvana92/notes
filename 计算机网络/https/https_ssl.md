**http的痛点:** 客户端提交的数据和服务端返回的数据都可以被监听, 甚至还可以被篡改请求信息。提交到服务器。



**第一阶段处理方案:** 通过对称加密对数据进行处理。

客户端通过加密算法[凯撒加密等等] 将加密后的数据传输到服务端。

服务端同样通过解密算法对提交的数据进行解密。

**问题:** 但是加密解密的算法中间人还是可以窃取。所以还是保证不了安全。



**第二阶段处理方案:** 通过在加密解密算法上加盐的方式处理。保证即使中间人知道算法也不能窃取客户端和服务端的数据传输。

**问题:** 如何保证盐在传输的过程中不被中间人窃取。



http 就是使用对称加密算法和保证秘钥不被窃取来保证安全的。

> 对称加密: 加密和解密使用的是同一把钥匙。(des, 3des, aes, 凯撒加密[移位算法])



**重点: https通过非对称算法来保证秘钥不被窃取。[https的重点]**

>  非对称加密: 通过两个秘钥来实现。一个是公钥，一个是私钥。公钥和私钥是一对。通过公钥加密只有对应的私钥才能解密。所以叫非对称加密。(RSA)

私钥机密数据 -> 公钥解密

公钥加密 -> 私钥解密



**问题: 如果不保证公钥安全的传输[不被中间人窃取]到客户端是否有问题？**

有问题, 如果中间人窃取到公钥数据。可以伪造请求发给服务端。甚至可以伪造一个对假的公钥、私钥并将公钥传输到客户端。不安全。



**<font color='red'>上面的问题演变成了服务端如何将公钥安全的传输到客户端。</font>**



> hash算法[摘要算法]: 算法(入参) = 结果。相同的入参对应相同的结果。结果反推不了入参。

hash算法引入数字签名。



**服务端:** 

1. server -> 第三方私钥(server.公钥) = 密文

2. hash(server.公钥) = 签名

3. 密文 + 签名 + 签名算法 = 证书



**客户端:** 

1. 系统中的第三方.公钥解密(证书) = server.公钥 + 签名+签名算法

2. 通过签名算法比对hash值。



重点: 随机串不会被窃取。[即最开始的盐不会被窃取]。建立好连接后面都是对称加密通信。

![image-20201101234646789](/Users/mac/Documents/GitHub/notes/计算机网络/https/image-20201101234646789.png)